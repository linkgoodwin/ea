#property copyright "Generated by Cursor AI Assistant"
#property link      "https://"
#property version   "1.00"
#property strict

#include <Trade/Trade.mqh>

input ENUM_TIMEFRAMES InpSignalTimeframe = PERIOD_H1;   // Signal timeframe
input int             InpDMIPeriod       = 14;           // DMI/ADX period
input double          InpLotsPer200USD   = 0.01;         // 0.01 lot per $200 balance
input bool            InpUsePrevCandleSL = true;         // Use previous candle high/low for initial SL
input double          InpInitialSLPct    = 0.1;          // Initial SL distance as percent of entry price (0.1%)
input double          InpTrailStepPct    = 0.01;         // Trailing step per interval as percent of entry price (0.01%)
input int             InpTrailIntervalS  = 180;          // Trailing step interval in seconds (3 minutes)

// Trading engine
CTrade g_trade;

// Indicator handle
int g_adxHandle = INVALID_HANDLE;

// Bar processing state
datetime g_lastClosedBarTime = 0;

// Trailing state (single-symbol EA)
long     g_trailTicket               = 0;
bool     g_trailingInitialized       = false;
int      g_trailingStepsApplied      = 0;
datetime g_lastTrailingUpdateTime    = 0;
double   g_trailingEntryPrice        = 0.0;

// Utility: normalize lots to symbol constraints
double NormalizeVolumeToSymbol(double requestedVolume)
{
	double volumeMin  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
	double volumeMax  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
	double volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
	if(volumeStep <= 0.0)
		volumeStep = 0.01;
	if(requestedVolume < volumeMin)
		requestedVolume = volumeMin;
	if(requestedVolume > volumeMax)
		requestedVolume = volumeMax;
	// Round down to step to avoid broker rejection
	int steps = (int)MathFloor((requestedVolume - volumeMin + 1e-12) / volumeStep);
	double normalized = volumeMin + steps * volumeStep;
	return normalized;
}

// Utility: compute lots based on balance: 0.01 per $200
double ComputeLotSize()
{
	double balance = AccountInfoDouble(ACCOUNT_BALANCE);
	double rawLots = (balance / 200.0) * InpLotsPer200USD; // 0.01 per 200 USD
	return NormalizeVolumeToSymbol(rawLots);
}

// Utility: check there is no open position for symbol
bool HasOpenPosition(const string symbol, long &ticketOut)
{
	if(!PositionSelect(symbol))
		return false;
	ticketOut = (long)PositionGetInteger(POSITION_TICKET);
	return true;
}

// Utility: get min stop distance in price units
double MinStopDistancePrice()
{
	long stopsLevelPoints = (long)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
	double pointValue      = _Point;
	return (stopsLevelPoints > 0 ? stopsLevelPoints * pointValue : 0.0);
}

// Utility: clamp SL price to allowed distance from current price
bool ClampStopForBuy(double &slPrice)
{
	double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
	double minDist = MinStopDistancePrice();
	double maxAllowedSL = bid - minDist;
	if(slPrice > maxAllowedSL)
		slPrice = maxAllowedSL;
	if(slPrice <= 0.0)
		return false;
	slPrice = NormalizeDouble(slPrice, (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS));
	return true;
}

bool ClampStopForSell(double &slPrice)
{
	double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
	double minDist = MinStopDistancePrice();
	double minAllowedSL = ask + minDist;
	if(slPrice < minAllowedSL)
		slPrice = minAllowedSL;
	if(slPrice <= 0.0)
		return false;
	slPrice = NormalizeDouble(slPrice, (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS));
	return true;
}

// Indicator data fetch for bars [1] and [2] (closed bars), plus ADX history for ADXR
bool LoadDMI_ADX_ADXR(double &pdi_1, double &pdi_2,
					  double &mdi_1, double &mdi_2,
					  double &adx_1, double &adx_2,
					  double &adxr_1, double &adxr_2)
{
	if(g_adxHandle == INVALID_HANDLE)
		return false;

	int need = InpDMIPeriod + 3; // enough to compute ADXR for [1] and [2]
	double adx[];  ArraySetAsSeries(adx,  true);
	double pdi[];  ArraySetAsSeries(pdi,  true);
	double mdi[];  ArraySetAsSeries(mdi,  true);
	int copied0 = CopyBuffer(g_adxHandle, 0, 0, need, adx); // ADX main
	int copied1 = CopyBuffer(g_adxHandle, 1, 0, need, pdi); // +DI
	int copied2 = CopyBuffer(g_adxHandle, 2, 0, need, mdi); // -DI
	if(copied0 < need || copied1 < 3 || copied2 < 3)
		return false;

	// Closed bars indexes: 1 and 2
	pdi_1 = pdi[1]; pdi_2 = pdi[2];
	mdi_1 = mdi[1]; mdi_2 = mdi[2];
	adx_1 = adx[1]; adx_2 = adx[2];

	// ADXR(t) = (ADX(t) + ADX(t - period)) / 2
	int idx1_past = 1 + InpDMIPeriod;
	int idx2_past = 2 + InpDMIPeriod;
	if(copied0 <= idx2_past)
		return false;
	adxr_1 = 0.5 * (adx[1] + adx[idx1_past]);
	adxr_2 = 0.5 * (adx[2] + adx[idx2_past]);
	return true;
}

// Check for cross conditions on closed bar
bool IsLongEntrySignal()
{
	double pdi1, pdi2, mdi1, mdi2, adx1, adx2, adxr1, adxr2;
	if(!LoadDMI_ADX_ADXR(pdi1, pdi2, mdi1, mdi2, adx1, adx2, adxr1, adxr2))
		return false;
	bool crossPDI = (pdi2 <= mdi2) && (pdi1 > mdi1);
	bool crossADX = (adx2 <= adxr2) && (adx1 > adxr1);
	return (crossPDI && crossADX);
}

bool IsShortEntrySignal()
{
	double pdi1, pdi2, mdi1, mdi2, adx1, adx2, adxr1, adxr2;
	if(!LoadDMI_ADX_ADXR(pdi1, pdi2, mdi1, mdi2, adx1, adx2, adxr1, adxr2))
		return false;
	bool crossPDI = (pdi2 >= mdi2) && (pdi1 < mdi1);
	bool crossADX = (adx2 >= adxr2) && (adx1 < adxr1);
	return (crossPDI && crossADX);
}

// Exit conditions on closed bar
bool ShouldExitLong()
{
	double pdi1, pdi2, mdi1, mdi2, adx1, adx2, adxr1, adxr2;
	if(!LoadDMI_ADX_ADXR(pdi1, pdi2, mdi1, mdi2, adx1, adx2, adxr1, adxr2))
		return false;
	// Exit long when ADX crosses below ADXR
	bool crossADXDown = (adx2 >= adxr2) && (adx1 < adxr1);
	return crossADXDown;
}

bool ShouldExitShort()
{
	double pdi1, pdi2, mdi1, mdi2, adx1, adx2, adxr1, adxr2;
	if(!LoadDMI_ADX_ADXR(pdi1, pdi2, mdi1, mdi2, adx1, adx2, adxr1, adxr2))
		return false;
	// Exit short when ADX crosses above ADXR
	bool crossADXUp = (adx2 <= adxr2) && (adx1 > adxr1);
	return crossADXUp;
}

// Compute previous candle SL levels
bool ComputeInitialSL(const bool isBuy, double entryPrice, double &outSL)
{
	double sl = 0.0;
	if(InpUsePrevCandleSL)
	{
		double prevLow  = iLow(_Symbol, InpSignalTimeframe, 1);
		double prevHigh = iHigh(_Symbol, InpSignalTimeframe, 1);
		sl = isBuy ? prevLow : prevHigh;
	}
	else
	{
		double frac = InpInitialSLPct / 100.0; // convert percent to fraction
		sl = isBuy ? (entryPrice * (1.0 - frac)) : (entryPrice * (1.0 + frac));
	}
	bool ok = isBuy ? ClampStopForBuy(sl) : ClampStopForSell(sl);
	if(!ok)
		return false;
	outSL = sl;
	return true;
}

// Apply initial trailing SL (0.1%) immediately after entry if it is tighter than current SL
void TryApplyInitialTrailing(const bool isBuy)
{
	if(!PositionSelect(_Symbol))
		return;
	double entry = PositionGetDouble(POSITION_PRICE_OPEN);
	double currentSL = PositionGetDouble(POSITION_SL);
	double fracInit  = InpInitialSLPct / 100.0;
	double desiredSL = isBuy ? (entry * (1.0 - fracInit)) : (entry * (1.0 + fracInit));
	bool ok = isBuy ? ClampStopForBuy(desiredSL) : ClampStopForSell(desiredSL);
	if(!ok)
		return;
	// Only tighten towards profit
	if(isBuy)
	{
		if(currentSL == 0.0 || desiredSL > currentSL)
			g_trade.PositionModify(_Symbol, desiredSL, PositionGetDouble(POSITION_TP));
	}
	else
	{
		if(currentSL == 0.0 || desiredSL < currentSL)
			g_trade.PositionModify(_Symbol, desiredSL, PositionGetDouble(POSITION_TP));
	}
}

// Trailing step engine (called from OnTimer)
void StepTimedTrailing()
{
	long ticket = 0;
	if(!HasOpenPosition(_Symbol, ticket))
		return;
	// Initialize/reset state if position changed
	if(ticket != g_trailTicket)
	{
		g_trailTicket = ticket;
		g_trailingInitialized = false;
		g_trailingStepsApplied = 0;
		g_lastTrailingUpdateTime = 0;
		g_trailingEntryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
	}
	// Ensure initialized
	if(!g_trailingInitialized)
	{
		g_trailingInitialized = true;
		g_lastTrailingUpdateTime = TimeCurrent();
		g_trailingEntryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
	}
	// Enforce interval
	if((TimeCurrent() - g_lastTrailingUpdateTime) < InpTrailIntervalS)
		return;

	// Only move in profitable direction
	long type = (long)PositionGetInteger(POSITION_TYPE);
	double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
	double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
	double currentSL = PositionGetDouble(POSITION_SL);
	double fracInit = InpInitialSLPct / 100.0;
	double fracStep = InpTrailStepPct / 100.0;
	double baseSL = 0.0;
	double targetSL = 0.0;
	bool isBuy = (type == POSITION_TYPE_BUY);
	if(isBuy)
	{
		if(bid <= g_trailingEntryPrice)
			return; // not in profit
		baseSL = g_trailingEntryPrice * (1.0 - fracInit);
		targetSL = g_trailingEntryPrice * (1.0 - fracInit + fracStep * (g_trailingStepsApplied + 1));
		if(currentSL > 0.0)
			targetSL = MathMax(targetSL, currentSL); // never loosen
		if(!ClampStopForBuy(targetSL))
			return;
		if(targetSL > 0.0 && targetSL < bid)
		{
			if(g_trade.PositionModify(_Symbol, targetSL, PositionGetDouble(POSITION_TP)))
			{
				g_trailingStepsApplied++;
				g_lastTrailingUpdateTime = TimeCurrent();
			}
		}
	}
	else if(type == POSITION_TYPE_SELL)
	{
		if(ask >= g_trailingEntryPrice)
			return; // not in profit
		baseSL = g_trailingEntryPrice * (1.0 + fracInit);
		targetSL = g_trailingEntryPrice * (1.0 + fracInit - fracStep * (g_trailingStepsApplied + 1));
		if(currentSL > 0.0)
			targetSL = MathMin(targetSL, currentSL); // never loosen
		if(!ClampStopForSell(targetSL))
			return;
		if(targetSL > 0.0 && targetSL > ask)
		{
			if(g_trade.PositionModify(_Symbol, targetSL, PositionGetDouble(POSITION_TP)))
			{
				g_trailingStepsApplied++;
				g_lastTrailingUpdateTime = TimeCurrent();
			}
		}
	}
}

// Entry helpers
bool OpenBuy()
{
	double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
	double lots = ComputeLotSize();
	double sl   = 0.0;
	if(!ComputeInitialSL(true, ask, sl))
		return false;
	bool sent = g_trade.Buy(lots, _Symbol, ask, sl, 0.0, "BitcoinDMI_EA");
	if(sent)
		TryApplyInitialTrailing(true);
	return sent;
}

bool OpenSell()
{
	double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
	double lots = ComputeLotSize();
	double sl   = 0.0;
	if(!ComputeInitialSL(false, bid, sl))
		return false;
	bool sent = g_trade.Sell(lots, _Symbol, bid, sl, 0.0, "BitcoinDMI_EA");
	if(sent)
		TryApplyInitialTrailing(false);
	return sent;
}

// Close existing position if any
void ClosePositionIfAny()
{
	if(!PositionSelect(_Symbol))
		return;
	g_trade.PositionClose(_Symbol);
}

int OnInit()
{
	g_adxHandle = iADX(_Symbol, InpSignalTimeframe, InpDMIPeriod);
	if(g_adxHandle == INVALID_HANDLE)
		return INIT_FAILED;
	EventSetTimer(InpTrailIntervalS);
	// Initialize last closed bar time
	datetime times[2];
	if(CopyTime(_Symbol, InpSignalTimeframe, 0, 2, times) == 2)
		g_lastClosedBarTime = times[1];
	return INIT_SUCCEEDED;
}

void OnDeinit(const int reason)
{
	if(g_adxHandle != INVALID_HANDLE)
	{
		IndicatorRelease(g_adxHandle);
		g_adxHandle = INVALID_HANDLE;
	}
	EventKillTimer();
}

void ProcessSignalsOnNewBar()
{
	// Detect new closed bar on selected timeframe
	datetime times[2];
	if(CopyTime(_Symbol, InpSignalTimeframe, 0, 2, times) != 2)
		return;
	if(times[1] == g_lastClosedBarTime)
		return;
	g_lastClosedBarTime = times[1];

	// Manage existing position exits
	if(PositionSelect(_Symbol))
	{
		long type = (long)PositionGetInteger(POSITION_TYPE);
		if(type == POSITION_TYPE_BUY)
		{
			if(ShouldExitLong())
				g_trade.PositionClose(_Symbol);
		}
		else if(type == POSITION_TYPE_SELL)
		{
			if(ShouldExitShort())
				g_trade.PositionClose(_Symbol);
		}
		return; // Do not open new position on same bar if one existed
	}

	// No open position: check entries
	if(IsLongEntrySignal())
	{
		OpenBuy();
	}
	else if(IsShortEntrySignal())
	{
		OpenSell();
	}
}

void OnTick()
{
	ProcessSignalsOnNewBar();
}

void OnTimer()
{
	StepTimedTrailing();
}